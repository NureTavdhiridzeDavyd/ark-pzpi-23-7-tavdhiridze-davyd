МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмна інженерія»




ЗВІТ
до практичного завдання  №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему «Правила оформлення програмного коду С#»





Виконав:                                                                                                  Перевірив:
ст. гр. ПЗПІ-23-7                                                    		 ст. викладач катедри ПІ
Тавдгірідзе Давид						 Сокорчук Ігор Петрович





Харків 2025


2 ЗАВДАННЯ
Мета заняття:
Метою заняття є ознайомлення з основними принципами рефакторингу в мові C# та вивчення рекомендацій Microsoft щодо написання чистого, структурованого та підтримуваного коду. Під час роботи розглядаються найбільш поширені проблеми у програмному коді та способи їх усунення за допомогою технік рефакторингу, таких як заміна кодів помилок винятками, виділення об’єктів замість масивів та перетворення великих методів на окремі класи. Акцент робиться на тому, як ці методи покращують якість програмного забезпечення та роблять його більш зрозумілим для розробників.
Завдання:
Дослідити практичні рекомендації Microsoft C# Coding Conventions і продемонструвати їх застосування на прикладах реального коду. Для цього було проаналізовано фрагменти з типовими помилками, показано їх слабкі місця та виконано покроковий рефакторинг. У процесі пояснювалося, чому обрані методи покращують читабельність, логіку та надійність коду, і як вони впливають на загальну архітектуру програмного рішення.



















3 ОПИС ВИКОНАНОЇ РОБОТИ
Переваги рефакторингу 
Рефакторинг – це систематичне покращення коду без зміни його зовнішньої поведінки. Він робить код значно читабельнішим, спрощує додавання нових функцій і зменшує час на пошук та виправлення помилок. Добре структурований код легше масштабувати, тестувати й передавати іншим розробникам. У довгостроковій перспективі регулярний рефакторинг знижує технічний борг і підвищує стабільність усієї системи.
Replace Error Code with Exception – проблема Використання спеціальних «магічних» значень для позначення помилок є поширеною антипрактикою. Коли метод повертає -1, null чи 0 замість нормального результату, викликаючий код змушений постійно перевіряти ці значення. Такі перевірки легко забути, вони захаращують основну логіку й роблять код важким для розуміння.
Код до рефакторингу 
У цьому прикладі метод повертає -1 у разі будь-якої проблеми. Викликаючий код вимушений вручну перевіряти результат на це магічне значення, і якщо перевірку пропустити – помилка залишиться непоміченою й може призвести до некоректної роботи програми.

public decimal GetAccountBalance(string accountId)
{
    if (string.IsNullOrEmpty(accountId))
        return -1;

    var account = FindAccount(accountId);
    if (account == null)
        return -1;

    return account.Balance;
}

// Виклик:
decimal balance = service.GetAccountBalance(id);
if (balance == -1)
    Console.WriteLine("Помилка отримання балансу");
Код після рефакторингу 
Після заміни кодів помилок на винятки основна логіка стала чистою й лінійною. Тепер неможливо випадково проігнорувати помилку – якщо виняток не обробити, програма зупиниться з чітким повідомленням і стеком викликів. Використовуються спеціалізовані винятки ArgumentException та власний AccountNotFoundException, що робить обробку помилок точною й зрозумілою.

public decimal GetAccountBalance(string accountId)
{
    if (string.IsNullOrEmpty(accountId))
        throw new ArgumentException("accountId не може бути порожнім", nameof(accountId));

    var account = FindAccount(accountId)
        ?? throw new AccountNotFoundException($"Рахунок {accountId} не знайдено");

    return account.Balance;
}

// Виклик:
try
{
    decimal balance = service.GetAccountBalance(id);
    Console.WriteLine($"Баланс: {balance}");
}
catch (AccountNotFoundException ex) { Console.WriteLine(ex.Message); }
catch (ArgumentException ex) { Console.WriteLine(ex.Message); }

Переваги використання винятків 
Винятки чітко відокремлюють нормальний потік виконання від помилкових ситуацій, забезпечують детальну інформацію про місце й причину помилки, неможливо їх випадково проігнорувати. Такий підхід повністю відповідає офіційним рекомендаціям Microsoft щодо обробки помилок у C#.
Replace Method with Method Object  
Дуже довгі методи з великою кількістю локальних змінних важко розбивати на менші приватні методи, тому що локальні змінні не можна передати між ними. Код стає монолітним, важким для читання й практично неможливим для юніт-тестування.
Код до рефакторингу 
Метод CalculateTotalPrice містить розрахунок базової ціни, знижки, податку й доставки в одному місці. Усі проміжні значення зберігаються в локальних змінних, через що метод виглядає громіздким і складним для підтримки.

public decimal CalculateTotalPrice(Order order)
{
    decimal basePrice = order.Quantity * order.UnitPrice;
    decimal discount = 0;

    if (order.Quantity > 100)
        discount = basePrice * 0.1m;
    else if (order.Quantity > 50)
        discount = basePrice * 0.05m;

    decimal tax = (basePrice - discount) * 0.2m;
    decimal shipping = CalculateShipping(order.Weight);

    if (order.IsExpressDelivery)
        shipping *= 1.5m;

    return basePrice - discount + tax + shipping;
}
Код після рефакторингу 
Уся логіка винесена в окремий клас PriceCalculator. Кожна локальна змінна стала полем класу, а великий метод розбитий на маленькі приватні методи з зрозумілими назвами. Тепер кожен етап розрахунку можна протестувати окремо, а сам клас легко розширювати новими правилами.

public class PriceCalculator
{
    private readonly Order _order;
    private decimal _basePrice, _discount, _tax, _shipping;

    public PriceCalculator(Order order) => _order = order;

    public decimal Calculate()
    {
        CalculateBasePrice();
        CalculateDiscount();
        CalculateTax();
        CalculateShipping();
        return _basePrice - _discount + _tax + _shipping;
    }

    private void CalculateBasePrice() =>
        _basePrice = _order.Quantity * _order.UnitPrice;

    private void CalculateDiscount() => _discount = _order.Quantity switch
    {
        > 100 => _basePrice * 0.10m,
        > 50  => _basePrice * 0.05m,
        _     => 0m
    };

    private void CalculateTax() =>
        _tax = (_basePrice - _discount) * 0.20m;

    private void CalculateShipping()
    {
        _shipping = ShippingCalculator.Calculate(_order.Weight);
        if (_order.IsExpressDelivery) _shipping *= 1.5m;
    }
}

// Виклик став дуже простим:
decimal total = new PriceCalculator(order).Calculate();
Переваги техніки 
Отримуємо високу модульність і чудову тестованість. Клас PriceCalculator можна перевикористовувати в інших частинах системи, а додавання нових знижок чи типів доставки не порушує існуючий код.
Replace Array with Object 
Масиви чи кортежі з «магічними» індексами змушують пам’ятати, що означає позиція 0, 1 чи 2. При зміні структури легко допустити помилку, а компілятор не допоможе виявити її на етапі компіляції.
Код до рефакторингу 
Дані про студента зберігаються в масиві об’єктів. Доступ здійснюється через індекси, що робить код крихким і важким для розуміння вже через кілька місяців.

var studentData = new object[] { "Олена", 21, "A+" };   // що в якому індексі?

string name = (string)studentData[0];
int age = (int)studentData[1];
string grade = (string)studentData[2];


Код після рефакторингу 
Створено типізований record Student з іменованими властивостями. Тепер код самодокументований, IntelliSense підказує назви полів, а компілятор перевіряє правильність типів. При потребі легко додати валідацію в конструкторі.
public record Student(string Name, int Age, string Grade);

// Або з валідацією:
public class Student
{
    public string Name { get; }
    public int Age { get; }
    public string Grade { get; }

    public Student(string name, int age, string grade)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
        if (age <= 0) throw new ArgumentOutOfRangeException(nameof(age));
        Grade = grade ?? throw new ArgumentNullException(nameof(grade));
    }
}

var student = new Student("Олена", 21, "A+");
Console.WriteLine($"Ім'я: {student.Name}, Вік: {student.Age}");
Переваги заміни масиву на об’єкт 
Чітка семантика даних, безпека типів, можливість інкапсуляції логіки та валідації, підтримка IntelliSense роблять код значно зрозумілішим і менш схильним до помилок.








4 ВИСНОВКИ
У ході виконання практичного завдання було детально досліджено та застосовано ключові техніки рефакторингу в мові C#. Проведений аналіз показав, що заміна кодів помилок на винятки (Replace Error Code with Exception) усуває магічні значення, робить обробку помилок надійною та відповідає рекомендаціям Microsoft. Перетворення складних методів на окремі класи (Replace Method with Method Object) суттєво підвищило модульність і тестованість коду. Заміна масивів з магічними індексами на типізовані об’єкти (Replace Array with Object) забезпечила безпеку типів, самодокументованість і можливість валідації даних.
Усі розглянуті рефакторинги покращують читабельність, підтримуваність і розширюваність коду, зменшують технічний борг і знижують ризик виникнення помилок. Виконана робота підтвердила, що рефакторинг є постійною дисципліною професійної розробки на C#, яка безпосередньо впливає на якість і довгострокову стабільність програмного забезпечення.

5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Refactoring. Martin Fowler, 2018. – 448 с.
2. Clean Code A Hadbook of Agile Software Craftsmanship [Електронний ресурс]. – Режим доступу: https://ptgmedia.pearsoncmg.com/images/9780132350884/samplepages/9780132350884.pdf?utm_source=chatgpt.com(дата звернення: 01.12.2025).
3. Microsoft .NET Documentation. [Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions(дата звернення: 01.12.2025).

ДОДАТОК А
https://youtu.be/3NRT3u56NJU




ДОДАТОК Б

Рисунок Б.1 – 

Рисунок Б.2 – 

Рисунок Б.3 – 

Рисунок Б.4 – 

Рисунок Б.5 – 

 Рисунок Б.6 – 

 Рисунок Б.7 – 

 Рисунок Б.8 – 

 Рисунок Б.9 – 

 Рисунок Б.10 – 

 Рисунок Б.11 – 

Рисунок Б.12 – 

 Рисунок Б.13 – Джерела, використані при роботі 
2


