

МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»





ЗВІТ
з лабораторної роботи 4
з дисципліни «Аналіз та рефакторінг коду»
на тему «РОЗРОБКА IoT КЛІЄНТА 
(БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)»



Виконав:
ст. гр. ПЗПІ-23-7
Тавдгірідзе Д.Д.


Перевірив: Викладач Дашенков Д.С.





Харків 2025


1. БУДОВА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ІоT-КЛІЄНТА
   IoT-клієнт «SmartDriveTracker» є частиною програмної системи HiveTrack і призначений для збору телеметричних даних під час практичних занять з водіння, їхньої попередньої обробки та передавання узагальнених результатів на серверну частину системи. Клієнт моделює роботу вбудованого пристрою, розміщеного в навчальному автомобілі, та забезпечує розширену функціональність, що відповідає концепції IoT-рішень для автошкіл.
   Програмне забезпечення IoT-клієнта має модульну структуру, що спрощує супровід та подальший розвиток. Основні компоненти клієнта:
* ConfigModule (модуль налаштувань) – відповідає за зберігання та зміну параметрів роботи пристрою: адреса серверної частини HiveTrack, ідентифікатори інструктора, групи та автомобіля, інтервали збору й відправки даних, порогові значення швидкості та допустимих порушень. Налаштування зберігаються у конфігураційному файлі та можуть змінюватися користувачем через консольний інтерфейс.
* SensorModule (модуль збору даних) – забезпечує отримання телеметричних даних. У демонстраційній реалізації значення сенсорів (швидкість руху, кількість різких гальмувань, умовні порушення смуги руху тощо) симулюються програмно, що дозволяє перевірити логіку роботи IoT-клієнта без використання реального обладнання.
* LogicModule (модуль бізнес-логіки) – виконує обробку зібраних даних з урахуванням налаштувань. На основі вибірок телеметрії обчислюються інтегральні показники якості водіння за сесію: середня швидкість, кількість подій ризикової поведінки, індекс безпечного водіння. Результат класифікується за категоріями (наприклад, Good, Need improvement, Bad), що надалі використовується в аналітичних модулях HiveTrack.
* NetworkModule (модуль взаємодії з сервером) – реалізує обмін даними з серверною частиною системи за протоколом HTTP із використанням REST-API. Модуль формує JSON-повідомлення з підсумковими результатами сесій водіння та надсилає їх на відповідний ендпоінт серверу. У разі помилки передбачені повторні спроби відправки або тимчасове збереження даних у локальній черзі.
* SessionController (керування сесією) – координує роботу всіх модулів та реалізує життєвий цикл сесії водіння. Під час запуску сесії модуль ініціалізує налаштування, періодично опитує SensorModule, передає дані в LogicModule, а після завершення формує підсумковий звіт та передає його в NetworkModule.
* ConsoleUI (консольний інтерфейс користувача) – надає простий інтерфейс для інструктора або адміністратора: дозволяє налаштувати параметри пристрою, вказати ідентифікатор учня, запустити та завершити сесію, переглянути поточний стан IoT-клієнта.
   У якості програмної платформи для IoT-клієнта використовується середовище Node.js. Такий вибір забезпечує просту інтеграцію з REST-API серверної частини HiveTrack, швидку розробку бізнес-логіки та можливість подальшого перенесення рішення на реальні вбудовані пристрої або одноплатні комп’ютери.
   

   2. UML-ДІАГРАМА ПРЕЦЕДЕНТІВ ДЛЯ ІоT-КЛІЄНТА
   IoT-клієнт «SmartDriveTracker» розглядається як окрема підсистема в складі загальної системи HiveTrack. Він взаємодіє з інструктором автошколи, серверною частиною HiveTrack, а за потреби – з адміністратором системи, який виконує початкове налаштування пристрою. На діаграмі прецедентів показано, як саме ці актори використовують можливості IoT-клієнта.
   Основним актором є інструктор. Через IoT-клієнт він налаштовує параметри роботи пристрою, керує сесіями водіння та контролює поточний стан клієнта. Перед початком роботи інструктор може переглянути поточні налаштування (адресу сервера, ідентифікатори авто, групи, інструктора, інтервал збору даних, порогові значення швидкості та інші параметри) і за потреби змінити їх. Ці дії об’єднані у прецедент «Налаштувати IoT-клієнт», який включає операції перегляду та редагування конфігурації. Таким чином інструктор забезпечує коректну прив’язку пристрою до конкретної навчальної машини та групи, а також задає частоту збору телеметрії.
   Під час роботи з учнем інструктор ініціює прецедент «Запустити сесію водіння». У межах цього прецеденту відбувається активація збору даних із сенсорів: клієнт переходить у режим періодичного опитування SensorModule, фіксує швидкість, події різких гальмувань і порушень смуги, а також відмічає факти перевищення швидкості відносно налаштованого ліміту. Після завершення заняття інструктор виконує прецедент «Завершити сесію водіння». У цей момент IoT-клієнт передає зібрані дані до модуля бізнес-логіки, де проводиться обчислення середньої швидкості, підрахунок ризикових подій та розрахунок інтегрального індексу якості водіння. На основі отриманого значення визначається категорія сесії (наприклад, безпечна, така, що потребує покращення, або ризикована), після чого формується підсумковий звіт, придатний для відправки на серверну частину HiveTrack.
   Серверна частина HiveTrack виступає окремим актором, що взаємодіє з IoT-клієнтом через мережу. У межах прецеденту «Надіслати результати на сервер» клієнт відправляє сформований підсумковий звіт сесії водіння на REST-ендпоінт серверу. Після цього відбувається прецедент «Отримати підтвердження прийому даних»: сервер повертає відповідь про успішне збереження інформації або повідомляє про помилку. У разі збоїв може бути задіяний додатковий прецедент «Повторити відправку даних», який розширює базовий сценарій надсилання результатів. У цьому випадку клієнт або повторює спробу через певний проміжок часу, або тимчасово зберігає звіт локально до відновлення зв’язку.
   Таким чином, UML-діаграма прецедентів відображає повний набір основних сценаріїв роботи IoT-клієнта «SmartDriveTracker»: від початкового налаштування й запуску сесій водіння до обробки їхніх результатів та передавання даних на серверну частину HiveTrack. Вона демонструє розподіл відповідальності між акторами та роль кожного прецеденту в загальному життєвому циклі навчальної поїздки.

Рисунок 2.1 - UML-діаграма прецедентів


3. БІЗНЕС-ЛОГІКА IoT-КЛІЄНТА ТА ФУНКЦІЇ НАЛАШТУВАННЯ
     Бізнес-логіка IoT-клієнта «HiveTracker» описує повний цикл навчальної поїздки. Після запуску програма завантажує конфігурацію, підготовлює параметри роботи і переходить у режим очікування команд від інструктора. Коли інструктор запускає сесію, клієнт ініціалізує внутрішні лічильники, а далі періодично опитує модуль сенсорів: отримує симульовані значення швидкості, фіксує факти різких гальмувань і порушень смуги руху, визначає перевищення швидкості відносно заданого ліміту. Усі вимірювання накопичуються в структурі сесії й використовуються як вхідні дані для подальших обчислень.
     Після завершення сесії IoT-клієнт передає зібрану телеметрію до модуля бізнес-логіки. На основі цих даних обчислюється середня швидкість за весь період, підраховується загальна кількість подій ризикової поведінки (різкі гальмування, порушення смуги, перевищення швидкості), а також розраховується інтегральний індекс безпечного водіння score. Значення score формується за принципом «100 мінус штрафи» з урахуванням коефіцієнтів для кожного типу подій, після чого переводиться у текстову категорію якості водіння (умовно «Good», «Need improvement» або «Bad»). Разом з цими показниками формуються службові дані сесії — ідентифікатори інструктора, учня, авто та групи, тривалість заняття, короткий підсумковий звіт — і все це готується до відправки на серверну частину HiveTrack.
     Окремий блок логіки відповідає за налаштування клієнта. Конфігурація зберігається у файлі (наприклад, config.json) і містить адресу серверу, ідентифікатори інструктора, групи й автомобіля, інтервал збору й відправки даних, ліміт швидкості та штрафні коефіцієнти для формули score. Під час запуску модуль ConfigModule завантажує ці дані, а консольний інтерфейс дозволяє інструктору переглядати й змінювати ключові параметри. Перед збереженням нових значень виконується базова перевірка коректності (діапазони інтервалів, адекватність лімітів, непорожні ідентифікатори, додатні коефіцієнти). У разі помилки користувач отримує відповідне повідомлення, а некоректні налаштування не застосовуються. Таким чином параметри роботи клієнта та логіка обробки телеметрії утворюють цілісну модель, яка дозволяє перетворювати «сирі» дані поїздки на зрозумілі оціночні показники для системи HiveTrack.

Рисунок 3.1 – Діаграма діяльності
4. ПРОГРАМНА РЕАЛІЗАЦІЯ
     Програмна реалізація IoT-клієнта виконана на платформі Node.js та інтегрована у вже наявний серверний проєкт HiveTrack. У репозиторії створено окремий підкаталог src/iotClient, де розміщені основні модулі клієнта: файл конфігурації config.json, модуль роботи з налаштуваннями config.js, модуль симуляції сенсорів sensor.js, клас для опису сесії водіння session.js та головний файл client.js, який відповідає за запуск і демонстрацію роботи IoT-клієнта. На стороні сервера додано контролер src/controllers/iotController.js, через який клієнт передає результати сесій за протоколом HTTP.
     У файлі config.js реалізовано завантаження й базову валідацію налаштувань з конфігураційного файлу. Під час запуску клієнта викликається функція loadConfig(), яка читає config.json, перевіряє коректність основних параметрів (адреса серверу, ідентифікатори інструктора, групи та автомобіля, інтервал відправки, ліміт швидкості, значення штрафних коефіцієнтів) і, у разі помилки, підставляє значення за замовчуванням. Такий підхід дозволяє відокремити конфігурацію від коду й спрощує налаштування клієнта без перекомпіляції програми.
     Модуль sensor.js відповідає за імітацію роботи вбудованих сенсорів. Єдина експортована функція generateSample(config) генерує тестовий вимір телеметрії: випадкову швидкість у діапазоні 0–100, імовірні події різкого гальмування та порушення смуги, а також факт перевищення швидкості відносно параметра speedLimit. Завдяки цьому клієнт може демонструвати повноцінний цикл збору даних без підключення до реального обладнання.
     Бізнес-логіка сесії водіння інкапсульована в класі DrivingSession, реалізованому у файлі session.js. Під час створення екземпляра класу зберігаються налаштування, ідентифікатор учня та часові мітки початку сесії. Метод addSample() додає окремий вимір, накопичуючи швидкості й лічильники ризикових подій. Після завершення сесії викликається метод finish(), який обчислює середню швидкість, загальну кількість різких гальмувань, порушень смуги та перевищень швидкості, розраховує інтегральний показник score за формулою «100 мінус штрафи» з урахуванням коефіцієнтів k1, k2, k3, визначає текстову категорію якості водіння та формує підсумковий об’єкт звіту з повною інформацією про сесію.
     Головна логіка запуску IoT-клієнта реалізована у файлі client.js. При запуску програми спочатку виводиться службове повідомлення про завантаження клієнта, далі здійснюється читання конфігурації та виведення її в консоль для наглядної перевірки. Ідентифікатор учня передається як аргумент командного рядка (наприклад, student-123). Після цього створюється новий об’єкт DrivingSession, і в циклі генерується фіксована кількість вимірювань телеметрії. Для кожного кроку в консоль виводиться рядок на зразок:
Sample #10: speed=64, hardBrake=0, laneViolation=0, overspeed=1
     Таким чином можна відстежити, які саме події було змодельовано протягом сесії. Коли всі вимірювання додано, викликається метод finish(), формується підсумковий звіт і виводиться у вигляді структурованого об’єкта з полями studentId, instructorId, groupId, carId, часовими мітками startedAt та finishedAt, тривалістю сесії, середньою швидкістю, кількістю всіх типів ризикових подій, розрахованим score та категорією (у демонстраційному запуску, наприклад, було отримано значення score = 37 та категорію Bad через велику кількість перевищень швидкості).
     Для передавання результатів на сервер реалізовано асинхронну функцію sendReport(report, config), яка виконує HTTP-запит POST на адресу, вказану в config.serverUrl (у лабораторній роботі це http://localhost:3000/api/iot/sessions). Перед відправкою у консоль виводиться повідомлення «Відправляю звіт на сервер», після чого програма логує код відповіді та тіло відповіді серверу. На серверній стороні створено контролер iotController, який обробляє маршрут /api/iot/sessions, приймає JSON-об’єкт із звітом, виводить його в консоль для діагностики та повертає клієнту відповідь зі статусом 201 Created і повідомленням про успішне отримання даних.
     У консолі сервера при цьому логувався отриманий JSON-звіт від IoT-клієнта. Це підтвердило коректну роботу як програмної реалізації бізнес-логіки клієнта, так і каналу взаємодії з серверною частиною HiveTrack. Отже, поставлені в лабораторній роботі завдання з розробки IoT-клієнта, реалізації функцій налаштування, обробки даних та передачі результатів у центральну систему були успішно виконані.
     Наведемо приклад результату в консолі:

Рисунок 4.1 – Схема пристрою

Рисунок 4.2 – Результат у консолі

ДОДАТОК А
Код ІоТ клієнта
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <WiFi.h>
#include <HTTPClient.h>

#define ONE_WIRE_BUS 12
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature tempSensors(&oneWire);

#define PIN_SPEED  34   
#define PIN_BRAKE  35   
#define PIN_LANE   32   

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32          
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

String DEVICE_SERIAL = "CAR-ESP32-001";
String GPS_LOCATION  = "49.9945914,36.2858247"; // умовні координати

const char* WIFI_SSID    = "Wokwi-GUEST";
const char* WIFI_PASS    = "";
const int   WIFI_CHANNEL = 6;

// замінити на мій сервер, при реальній роботі
String API_URL = "https://postman-echo.com/post";

float lastSpeed = 0;
int hardBrakes = 0;
int hardAccels = 0;
int laneViolations = 0;

float speedAccum = 0;
int speedSamples = 0;

const float K_HARD_BRAKE = 5.0;
const float K_HARD_ACCEL = 3.0;
const float K_LANE_VIOL  = 2.0;

float calcScore() {
  float base = 100.0;
  float penalty = K_HARD_BRAKE * hardBrakes
                + K_HARD_ACCEL * hardAccels
                + K_LANE_VIOL  * laneViolations;
  float score = base - penalty;
  if (score < 0) score = 0;
  if (score > 100) score = 100;
  return score;
}

void sendToBackend(float tempC, float currentSpeed) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected, skip send");
    return;
  }

  float avgSpeed = (speedSamples > 0) ? (speedAccum / speedSamples) : currentSpeed;
  float score = calcScore();

  HTTPClient http;
  http.begin(API_URL);
  http.addHeader("Content-Type", "application/json");

  String json = "{";
  json += "\"device_serial\":\"" + DEVICE_SERIAL + "\",";
  json += "\"gps_location\":\"" + GPS_LOCATION + "\",";
  json += "\"temperature\":" + String(tempC, 2) + ",";
  json += "\"current_speed\":" + String(currentSpeed, 1) + ",";
  json += "\"avg_speed\":" + String(avgSpeed, 1) + ",";
  json += "\"hard_brakes\":" + String(hardBrakes) + ",";
  json += "\"hard_accels\":" + String(hardAccels) + ",";
  json += "\"lane_violations\":" + String(laneViolations) + ",";
  json += "\"score\":" + String(score, 1);
  json += "}";

  Serial.println("=== SENDING JSON ===");
  Serial.println(json);

  int httpCode = http.POST(json);
  Serial.print("POST ");
  Serial.print(API_URL);
  Serial.print(" -> Status: ");
  Serial.println(httpCode);

  http.end();
}

void setupWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS, WIFI_CHANNEL);

  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
  }
  Serial.println();
  Serial.println("WiFi connected!");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

void setupOLED() {
  Wire.begin(2, 15); 

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("OLED init failed");
    for(;;); 
  }

  display.clearDisplay();
  display.display();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
}

void showOnOLED(float tempC, float speed, float score) {
  display.clearDisplay();

  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(DEVICE_SERIAL, 0, 0, &x1, &y1, &w, &h);
  int x_center = (SCREEN_WIDTH - w) / 2;
  display.setCursor(x_center, 0);
  display.print(DEVICE_SERIAL);

  display.setCursor(0, 12);
  display.print("SPD:");
  display.print(speed, 1);
  display.print(" km/h");

  display.setCursor(0, 24);
  display.print("SCR:");
  display.print(score, 0);
  display.print(" T:");
  display.print(tempC, 1);

  display.display();
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println();
  Serial.println("SmartDriveTracker (ESP32 + Wokwi) starting...");

  tempSensors.begin();

  pinMode(PIN_SPEED, INPUT);
  pinMode(PIN_BRAKE, INPUT);
  pinMode(PIN_LANE, INPUT);

  setupOLED();

  setupWiFi();
}

unsigned long lastSendMs = 0;
const unsigned long SEND_INTERVAL_MS = 2000;

void loop() {

  tempSensors.requestTemperatures();
  float tempC = tempSensors.getTempCByIndex(0);

  int rawSpeed = analogRead(PIN_SPEED);
  int rawBrake = analogRead(PIN_BRAKE);
  int rawLane  = analogRead(PIN_LANE);

  float speed    = map(rawSpeed, 0, 4095, 0, 150);   // 0..150 км/год
  float brakeAgg = map(rawBrake, 0, 4095, 0, 100);   // 0..100
  float laneDev  = map(rawLane, 0, 4095, 0, 100);    // 0..100

  float deltaV = speed - lastSpeed;

  if (deltaV < -20 && brakeAgg > 50) {
    hardBrakes++;
    Serial.println("[EVENT] Hard brake");
  }

  if (deltaV > 20) {
    hardAccels++;
    Serial.println("[EVENT] Hard acceleration");
  }

  if (laneDev > 70) {
    laneViolations++;
    Serial.println("[EVENT] Lane violation");
  }

  lastSpeed = speed;
  speedAccum += speed;
  speedSamples++;

  float score = calcScore();

  Serial.print("Temp: ");
  Serial.print(tempC);
  Serial.print(" C | Speed: ");
  Serial.print(speed);
  Serial.print(" km/h | HB:");
  Serial.print(hardBrakes);
  Serial.print(" HA:");
  Serial.print(hardAccels);
  Serial.print(" LV:");
  Serial.print(laneViolations);
  Serial.print(" | Score: ");
  Serial.println(score);

  showOnOLED(tempC, speed, score);

  unsigned long now = millis();
  if (now - lastSendMs > SEND_INTERVAL_MS) {
    lastSendMs = now;
    sendToBackend(tempC, speed);
  }

  delay(500);  
}



ДОДАТОК Б
Посилання на код
https://github.com/NureTavdhiridzeDavyd/ark-pzpi-23-7-tavdhiridze-davyd


ДОДАТОК В
Посилання на відео
https://youtu.be/idmuHeCuAvQ
