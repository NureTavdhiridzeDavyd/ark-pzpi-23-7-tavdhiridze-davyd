

МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»





ЗВІТ
з лабораторної роботи 3
з дисципліни «Аналіз та рефакторінг коду»
на тему «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»



Виконав:
ст. гр. ПЗПІ-23-7
Тавдгірідзе Д.Д.


Перевірив: Викладач Дашенков Д.С.





Харків 2025


1 ОПИС ІНЖЕНЕРНИХ РІШЕНЬ
1.1 Архітектурні рішення 
	Під час розробки серверної частини системи HiveTrack використано багатошарову архітектуру, наближену до підходу Clean Architecture. Така структура чітко розділяє відповідальність між презентаційним шаром (REST-API), бізнес-логікою та шаром доступу до даних, що спрощує супровід, тестування й подальше розширення системи.
Основні шари серверної частини:
* API-рівень (Controllers) — відповідає за прийом HTTP-запитів від клієнтських застосунків, валідацію вхідних даних на базовому рівні та формування HTTP-відповідей.
* Шар бізнес-логіки (Services) — містить основні правила предметної області автошколи: перевірку належності учня до групи, обмеження доступу за ролями, обробку результатів тестів, перерахунок показників прогресу тощо.
* Шар доступу до даних (Repositories / Data Access Layer) — інкапсулює всі SQL-запити до бази даних SQL Server та перетворює результати в об’єкти доменної моделі. Це дозволяє змінювати структуру таблиць або оптимізувати запити без впливу на бізнес-логіку.
У проєкті застосовано такі архітектурні патерни:
* Controller–Service–Repository — контролери не містять бізнес-логіки і лише делегують виконання сервісам, тоді як репозиторії відповідають за взаємодію з БД. Це зменшує зв’язність компонентів і полегшує модульне тестування.
* Repository Pattern — для основних сутностей (Users, Groups, Lessons, Attendance, Tests, TestAttempts, Notifications, ProgressMetrics) створені окремі репозиторії з чітко визначеними методами (створення, пошук, оновлення, видалення, фільтрація). Внутрішні SQL-запити приховані від бізнес-логіки.
* Dependency Injection (DI) — всі сервіси й репозиторії реєструються в контейнері залежностей і передаються через конструктор. Це дозволяє легко підмінювати реалізації (наприклад, для юніт-тестів або при зміні СУБД) і робить код більш гнучким. 
* DTO Pattern — для кожного публічного ендпоінта визначені DTO-класи запиту та відповіді, які використовуються на межі між API-рівнем та бізнес-логікою. Це обмежує набір полів, що передаються клієнту, і захищає внутрішню структуру моделей бази даних.
Взаємодія шарів відбувається за такою схемою:
1) Користувач (учень, інструктор або адміністратор автошколи) надсилає HTTP-запит до відповідного контролера REST-API.

2) Контролер виконує базову валідацію параметрів, витягує дані з JWT-токена (ідентифікатор користувача, роль) і викликає метод відповідного сервісу.
3) Сервіс застосовує бізнес-правила: перевіряє права доступу, коректність стану об’єктів (наявність групи, уроку, запису про зарахування), виконує розрахунки (бал за тест, відсоток відвідуваності, агреговані метрики прогресу) і звертається до репозиторіїв.
4) Репозиторій виконує параметризовані SQL-запити до SQL Server, отримує та перетворює дані у доменні моделі, які повертаються сервісу.
5) Сервіс формує DTO-об’єкт відповіді й повертає його контролеру, який відправляє клієнту HTTP-відповідь у форматі JSON.
6) Такий підхід дозволяє безболісно розширювати систему HiveTrack новими модулями (наприклад, додатковою аналітикою або інтеграцією з зовнішніми сервісами тестів ПДР), не змінюючи вже реалізовану бізнес-логіку та мінімізуючи ризик регресій.
1.2 Вибір технологій та інструментів
     Для реалізації серверної частини системи HiveTrack було обрано стек технологій, орієнтований на використання мови JavaScript як на клієнтському, так і на серверному боці. У якості платформи для побудови REST-API використовується середовище виконання Node.js та фреймворк Express. Такий підхід дозволяє створювати легкий та гнучкий веб-сервіс, який обробляє HTTP-запити, повертає відповіді у форматі JSON і легко інтегрується з фронтендом та зовнішніми системами. Express надає мінімалістичну, але розширювану модель маршрутизації й проміжного оброблення запитів (middleware), що спрощує реалізацію аутентифікації, логування, обробки помилок та інших крос-секційних задач.
     Для зберігання даних про користувачів, групи, заняття, результати тестів та метрики прогресу застосовується реляційна система керування базами даних MySQL (або сумісна MariaDB). Ця СУБД добре підходить для структурованих даних із чіткими зв’язками між таблицями, підтримує транзакції, індекси та складні SQL-запити. Структура бази даних описана за допомогою SQL-скриптів із використанням автоінкрементних первинних ключів, зовнішніх ключів та індексів для пришвидшення пошуку по часто використовуваних полях. Робота з базою даних на рівні коду виконується через окремий шар доступу до даних, де всі SQL-запити виконуються у вигляді параметризованих, що знижує ризик SQL-ін’єкцій, дозволяє централізовано оптимізувати запити та спрощує подальшу зміну СУБД або бібліотеки доступу до БД.
     Захист серверного API реалізовано за допомогою JSON Web Token (JWT). Після успішної аутентифікації користувач отримує токен, який містить його ідентифікатор та роль (Student, Instructor або Admin) і передається в заголовку Authorization при подальших запитах. Це дозволяє серверу без додаткового збереження сесійної інформації перевіряти особу користувача, контролювати доступ до ресурсів та реалізовувати рольову модель безпеки. Усі чутливі операції, пов’язані з управлінням користувачами, групами, заняттями та тестами, доступні лише за наявності валідного JWT-токена, який перевіряється на спеціальних middleware-рівнях.
     Для документування й тестування REST-інтерфейсу використовується специфікація OpenAPI та інструменти на базі Swagger (наприклад, swagger-jsdoc і swagger-ui-express). На основі опису ендпоінтів у вигляді анотацій або окремого YAML/JSON-файла автоматично генерується інтерактивна документація, де можна переглянути список доступних маршрутів, необхідні параметри запитів та приклади відповідей. Це суттєво спрощує розробку та інтеграцію клієнтських застосунків, а також дозволяє виконувати ручне тестування запитів безпосередньо з браузера.
     Логування подій та помилок у серверній частині реалізується за допомогою вбудованих можливостей Node.js та спеціалізованих бібліотек (наприклад, winston). У логах фіксуються ключові дії користувачів, результати виконання критичних бізнес-операцій та інформація про виняткові ситуації. Це полегшує діагностику проблем, аналіз роботи системи в експлуатації та пошук помилок під час розробки. Для перевірки коректності бізнес-логіки та окремих модулів можуть використовуватися фреймворки модульного тестування на кшталт Jest або Mocha, а також ручне тестування HTTP-запитів за допомогою Postman, Swagger UI чи аналогічних інструментів.
     Обраний стек технологій на базі Node.js, Express, MySQL, JWT та інструментів OpenAPI забезпечує гнучку й розширювану платформу для реалізації серверної частини HiveTrack, яка поєднує простоту розробки навчального проєкту з можливістю подальшого масштабування та розвитку системи.
1.3 Реалізована бізнес-логіка
     Бізнес-логіка системи HiveTrack побудована навколо основних процесів роботи автошколи: формування навчальних груп, планування й проведення занять, тестування учнів з правил дорожнього руху та відстеження їхнього прогресу. На рівні серверної частини ці процеси реалізовані у вигляді окремих модулів бізнес-логіки, які взаємодіють через сервіси та репозиторії і забезпечують цілісність даних у базі.
     Першим ключовим модулем є управління навчальними групами та заняттями. Серверна частина дозволяє адміністраторам та інструкторам створювати групи з вказанням назви, типу курсу, дат початку та завершення, а також призначати відповідальних інструкторів. Запис учнів до групи виконується через окрему бізнес-операцію, яка перевіряє, що користувач має роль “Student”, не видалений і не заблокований, а також що він ще не зарахований до цієї групи. Під час створення нового заняття сервіс уроків перевіряє існування вибраної групи й інструктора, відповідність ролі “Instructor” та відсутність конфліктів у розкладі: інструктор не може мати два заняття в один і той самий час, а урок повинен потрапляти в діапазон дат курсу. Після цього в базі даних створюється запис про урок з типом (теорія або практика), темою, датою та часом проведення.
     Фіксація відвідуваності також реалізована як окремий бізнес-процес. Коли інструктор відмічає присутність учнів на занятті, система для кожного учня перевіряє, чи зарахований він до відповідної групи та чи не існує вже запису відвідуваності для цієї пари “учень–заняття”. Це запобігає дублюванню даних і некоректним змінам журналу. Статус відвідування (присутній, відсутній, запізнився) зберігається разом з можливим коментарем інструктора, а агреговані показники відвідуваності використовуються далі в модулі прогресу. У підсумку модуль управління групами та заняттями забезпечує підтримку електронного журналу, який узгоджений із реальним розкладом та ролями користувачів у системі.
     Другим основним модулем є управління тестами ПДР та навчальним прогресом. Адміністратори та інструктори можуть створювати тести з вказанням назви, режиму (тренувальний або іспитовий), ліміту часу та переліку питань. Кожне питання містить декілька варіантів відповіді, серед яких позначаються правильні. Під час старту спроби тесту сервіс перевіряє, що тест активний, користувач має роль “Student”, а також що не перевищено дозволену кількість одночасних або загальних спроб (якщо такі обмеження встановлені правилами курсу). Для кожної спроби створюється запис із часом початку, посиланням на тест і учня, після чого учень може поступово надсилати відповіді на запитання.
     Завершення спроби тесту супроводжується виконанням низки бізнес-перевірок. Сервіс тестування контролює, чи не вийшов учень за межі відведеного часу, чи були надані відповіді лише для питань цього тесту, а також чи не змінювався склад тесту під час проходження. Після цього по кожному запитанню обчислюється, чи правильну відповідь обрав учень, рахується загальна кількість правильних відповідей та підсумковий бал. Результат зберігається в таблиці спроб тесту разом із часовими мітками, що дозволяє аналізувати історію спроб. На основі завершеної спроби окремий сервіс прогресу оновлює агреговані метрики для учня: відсоток правильних відповідей по темах, середній бал, кількість пройдених тестів, а також інтегрує ці дані з інформацією про відвідуваність занять.
     Бізнес-логіка модулів управління групами, заняттями та тестами тісно пов’язана з рольовою моделлю доступу. Усі операції виконуються від імені автентифікованого користувача, роль якого зчитується з JWT-токена. Це означає, що учень може переглядати свій розклад, проходити тести та бачити власний прогрес, але не має доступу до чужих даних та адміністративних функцій. Інструктор має право керувати заняттями й журналом відвідуваності лише для тих груп, де він призначений відповідальним, а адміністратор може виконувати повний обсяг операцій з управління користувачами, групами й тестами. Така побудова бізнес-логіки дозволяє системі HiveTrack відображати реальні процеси роботи автошколи, забезпечуючи при цьому контроль доступу й узгодженість даних на серверному рівні.
     1.4 Функції адміністрування
     Функції адміністрування в системі HiveTrack забезпечують централізоване керування користувачами, навчальними групами, тестами та загальними параметрами роботи автошколи. Усі адміністративні операції виконуються від імені користувачів із роллю Admin, що перевіряється на рівні проміжних обробників (middleware) у серверній частині. Після успішної валідації JWT-токена маршрути адміністратора передають керування сервісам бізнес-логіки, які реалізують конкретні правила предметної області та гарантують цілісність даних.
     Однією з ключових адміністративних можливостей є управління користувачами системи. Адміністратор може створювати нові облікові записи для учнів, інструкторів та інших адміністраторів, редагувати їхні профілі, змінювати ролі та статуси, а також блокувати доступ до системи у разі порушень правил. Під час блокування користувача сервер не видаляє його дані з бази, а лише змінює відповідний статус, щоб зберегти історію навчання, результати тестів та записи відвідуваності. Окремі бізнес-правила забороняють, наприклад, видаляти або розблоковувати останнього активного адміністратора, що запобігає втраті керування системою. Для зручності аналізу адміністратор може переглядати основні показники активності користувачів, включно з датою останнього входу, кількістю спроб тестів та участю в заняттях.
     Другим важливим напрямом адміністративних функцій є керування навчальними групами та курсами. Адміністратор створює групи, задає дати початку та завершення навчання, визначає тип курсу та призначає відповідальних інструкторів. Бізнес-логіка перевіряє, щоб у групи був хоча б один інструктор із відповідною роллю та щоб дати навчання відповідали загальним правилам формування розкладу. Адміністратор може відкривати та закривати набір до груп, переглядати поточний склад учнів, виконувати масовий запис або відрахування, а також архівувати завершені групи, зберігаючи історію їх розкладу й результатів. При спробі видалити групу з активними заняттями або незавершеними тестами бізнес-логіка блокує таку операцію й пропонує спочатку перенести або завершити відповідні об’єкти.
     Окремий блок функцій адміністрування пов’язаний із банком тестів ПДР та налаштуваннями оцінювання. Адміністратор має можливість створювати та редагувати тести, обираючи їх режим (тренувальний чи іспитовий), ліміт часу, мінімальний прохідний бал і кількість дозволених спроб. Для кожного тесту формуються набори запитань із варіантами відповідей, які можуть групуватися за темами чи модулями курсу. Якщо тест уже використовувався учнями, бізнес-логіка обмежує радикальні зміни його структури: наприклад, замість фізичного видалення запитується деактивація тесту або створення нової версії, щоб не порушувати коректність наявних результатів. Адміністратор також може керувати доступністю тестів для окремих груп, вмикаючи або вимикаючи їх у різні періоди навчання.
     Важливе місце в адміністративному модулі займає моніторинг успішності та відвідуваності. На основі агрегованих даних про спроби тестів і журнали занять серверна частина формує узагальнені показники: середній бал по групі, відсоток правильних відповідей по темах, рівень відвідуваності занять відносно запланованого розкладу. Адміністратор може переглядати ці показники в розрізі окремих груп, інструкторів або всього навчального центру, що дозволяє виявляти проблемні місця в організації навчання, рівень складності тестів чи навантаження на інструкторів. Завдяки цьому модуль адміністративної аналітики підтримує прийняття рішень щодо корекції програм, перерозподілу учнів або зміни складу викладачів.
     Додатково адміністративні функції включають керування системними сповіщеннями та загальними налаштуваннями платформи. Адміністратор може створювати глобальні повідомлення про зміни в розкладі, набір у нові групи, оновлення програми чи технічні роботи системи. Такі сповіщення зберігаються в базі даних і розповсюджуються відповідним користувачам через внутрішній механізм нотифікацій. На рівні налаштувань адміністратор має змогу змінювати деякі порогові значення, наприклад, мінімальний прохідний бал для іспитових тестів або політику щодо максимальної кількості одночасних спроб. Усі критичні адміністративні дії журналюються, що дозволяє простежити історію змін і, за необхідності, проаналізувати причини некоректної конфігурації чи помилкових операцій.
     У сукупності реалізовані функції адміністрування забезпечують гнучке та безпечне керування серверною частиною HiveTrack, дають змогу підтримувати актуальність даних про користувачів, групи та навчальні активності, а також дозволяють адаптувати систему до потреб конкретної автошколи без втручання у внутрішній код застосунку.
     

2  ФРАГМЕНТИ ПРОГРАМНОГО КОДУ
     У цьому розділі наведено приклади основних частин бізнес логіки та адміністративних функцій із коротким поясненням.
     ???2.1 Реалізація бізнес-логіки створення заняття
     Бізнес-логіка створення заняття реалізована у контролері lessonsController.js у вигляді методу createLesson. На відміну від простого CRUD-запису в базу даних, метод виконує ряд перевірок предметної області автошколи: перевіряє наявність усіх обов’язкових полів, існування навчальної групи, існування інструктора з роллю Instructor, а також відсутність конфлікту в розкладі інструктора на вказану дату й час. У разі порушення правил генерується виняток типу BusinessError, який перехоплюється глобальним обробником помилок і перетворюється на коректну HTTP-відповідь.

const db = require('../db');
const { BusinessError } = require('../errors/BusinessError');

exports.createLesson = async(req, res, next) = > {
    try {
        const { groupId, instructorId, type, topic, lessonDateTime } = req.body;

        if (!groupId || !instructorId || !type || !topic || !lessonDateTime) {
            throw new BusinessError(
                'Необхідні поля: groupId, instructorId, type, topic, lessonDateTime',
                400
            );
        }

        const [groupRows] = await db.query(
            'SELECT id FROM groups WHERE id = ?',
            [groupId]
        );
        if (groupRows.length == = 0) {
            throw new BusinessError('Навчальну групу не знайдено', 404);
        }

        const [instructorRows] = await db.query(
            'SELECT id, role FROM users WHERE id = ?',
            [instructorId]
        );
        const instructor = instructorRows[0];
        if (!instructor) {
            throw new BusinessError('Інструктора не знайдено', 404);
        }
        if (instructor.role != = 'Instructor') {
            throw new BusinessError('Користувач не має ролі Instructor', 400);
        }

        const [conflictRows] = await db.query(
            `SELECT COUNT(*) AS cnt
            FROM lessons
            WHERE instructor_id = ?
            AND lesson_datetime = ? `,
            [instructorId, lessonDateTime]
        );

        if (conflictRows[0].cnt > 0) {
            throw new BusinessError(
                'В обраний час інструктор уже має заплановане заняття',
                400
            );
        }

        const [result] = await db.query(
            `INSERT INTO lessons(group_id, instructor_id, type, topic, lesson_datetime)
            VALUES(? , ? , ? , ? , ? )`,
            [groupId, instructorId, type, topic, lessonDateTime]
        );

        const newId = result.insertId;

        const [rows] = await db.query(
            `SELECT
            id,
            group_id      AS groupId,
            instructor_id AS instructorId,
            type,
            topic,
            lesson_datetime AS lessonDateTime
            FROM lessons
            WHERE id = ? `,
            [newId]
        );

        res.status(201).json(rows[0]);
    }
    catch (err) {
        console.error('Error createLesson:', err);
        next(err);
    }
};

Таким чином, навіть якщо клієнт надсилає коректний за синтаксисом HTTP-запит, заняття буде створено лише у випадку виконання всіх бізнес-умов: існування групи, коректної ролі інструктора та відсутності конфлікту в його розкладі.
2.2 Реалізація адміністративних функцій керування користувачами та статистикою
Адміністративні функції реалізовані в контролері adminController.js. Перша функція blockUser дозволяє адміністратору заблокувати обліковий запис користувача з урахуванням додаткових обмежень: операцію може виконувати лише користувач із роллю Admin, адміністратор не може заблокувати сам себе, а також заборонено блокувати останнього активного адміністратора. Друга функція getUserStatistics формує агреговану статистику по користувачах, навчальних групах та спробах тестів і повертає її у вигляді JSON-об’єкта для подальшого відображення в адміністративній панелі.
const db = require('../db');
const { BusinessError } = require('../errors/BusinessError');

exports.blockUser = async (req, res, next) => {
  try {
    const targetUserId = parseInt(req.params.id, 10);
    const { currentAdminId } = req.body;

    if (!currentAdminId) {
      throw new BusinessError('Потрібно передати currentAdminId в тілі запиту', 400);
    }

    const [adminRows] = await db.query(
      'SELECT id, role FROM users WHERE id = ?',
      [currentAdminId]
    );
    const admin = adminRows[0];

    if (!admin || admin.role !== 'Admin') {
      throw new BusinessError('Лише адміністратор може блокувати користувачів', 403);
    }

    if (Number(currentAdminId) === Number(targetUserId)) {
      throw new BusinessError('Адміністратор не може заблокувати сам себе', 400);
    }

    const [userRows] = await db.query(
      'SELECT id, role, is_blocked AS isBlocked FROM users WHERE id = ?',
      [targetUserId]
    );
    const user = userRows[0];

    if (!user) {
      throw new BusinessError('Користувача не знайдено', 404);
    }

    if (user.role === 'Admin') {
      const [countRows] = await db.query(
        'SELECT COUNT(*) AS cnt FROM users WHERE role = "Admin" AND is_blocked = 0'
      );
      if (countRows[0].cnt <= 1) {
        throw new BusinessError(
          'Неможливо заблокувати останнього активного адміністратора',
          400
        );
      }
    }

    if (user.isBlocked) {
      return res.json({ message: 'Користувач уже заблокований' });
    }

    await db.query(
      'UPDATE users SET is_blocked = 1, blocked_at = NOW() WHERE id = ?',
      [targetUserId]
    );

    res.json({ message: 'Користувача успішно заблоковано' });
  } catch (err) {
    console.error('Error blockUser:', err);
    next(err);
  }
};

exports.getUserStatistics = async (req, res, next) => {
  try {
    const currentAdminId = req.query.currentAdminId;

    if (!currentAdminId) {
      throw new BusinessError('Потрібно передати currentAdminId в query-параметрі', 400);
    }

    const [adminRows] = await db.query(
      'SELECT id, role FROM users WHERE id = ?',
      [currentAdminId]
    );
    const admin = adminRows[0];

    if (!admin || admin.role !== 'Admin') {
      throw new BusinessError('Лише адміністратор може переглядати статистику користувачів', 403);
    }

    const [
      [totalUsersRows],
      [blockedUsersRows],
      [studentsRows],
      [instructorsRows],
      [adminsRows],
      [activeGroupsRows],
      [totalAttemptsRows],
      [passedAttemptsRows]
    ] = await Promise.all([
      db.query('SELECT COUNT(*) AS cnt FROM users'),
      db.query('SELECT COUNT(*) AS cnt FROM users WHERE is_blocked = 1'),
      db.query(`SELECT COUNT(*) AS cnt FROM users WHERE role = 'Student'`),
      db.query(`SELECT COUNT(*) AS cnt FROM users WHERE role = 'Instructor'`),
      db.query(`SELECT COUNT(*) AS cnt FROM users WHERE role = 'Admin'`),
      db.query('SELECT COUNT(*) AS cnt FROM groups WHERE is_archived = 0'),
      db.query('SELECT COUNT(*) AS cnt FROM test_attempts'),
      db.query('SELECT COUNT(*) AS cnt FROM test_attempts WHERE is_passed = 1')
    ]);

    const stats = {
      totalUsers: totalUsersRows[0].cnt,
      blockedUsers: blockedUsersRows[0].cnt,
      studentsCount: studentsRows[0].cnt,
      instructorsCount: instructorsRows[0].cnt,
      adminsCount: adminsRows[0].cnt,
      activeGroups: activeGroupsRows[0].cnt,
      totalTestAttempts: totalAttemptsRows[0].cnt,
      passedAttempts: passedAttemptsRows[0].cnt
    };

    res.json(stats);
  } catch (err) {
    console.error('Error getUserStatistics:', err);
    next(err);
  }
};

Наведені фрагменти демонструють, як у серверній частині HiveTrack бізнес-логіка (створення занять) та адміністративні операції (блокування користувачів і отримання зведеної статистики) відокремлені від простих SQL-запитів, реалізують правила предметної області автошколи та використовують єдиний механізм обробки помилок на основі класу BusinessError.


3 UML ДІАГРАМИ
3.1 Діаграма діяльності процесу створення заняття

Рисунок 3.1 – UML-Діаграма створення заняття
На діаграмі діяльності показано основні кроки бізнес-процесу створення заняття: від отримання HTTP-запиту до успішного створення запису в таблиці lessons або повернення помилки у випадку порушення бізнес-правил. Послідовно виконуються перевірки обов’язкових полів, існування групи, існування інструктора з коректною роллю та відсутності конфліктів у розкладі інструктора. У разі невдачі на будь-якому етапі генерується BusinessError, який призводить до повернення відповідного коду помилки клієнту.
3.2 Діаграма послідовності обробки запиту створення заняття

Рисунок 3.2 – UML-Діаграма взаємодії 
Діаграма послідовності деталізує взаємодію між учасниками процесу: клієнтом, сервером Express, контролером lessonsController, базою даних MySQL та глобальним обробником помилок. Показано, як викликається метод createLesson, як виконуються SQL-запити до таблиць groups, users та lessons, а також як у разі помилки генерується BusinessError.


ДОДАТОК А
Client.js
console.log(">>> IoT client file loaded");
const { loadConfig } = require("./config");
const { generateSample } = require("./sensor");
const DrivingSession = require("./session");

async function sendReport(report, config) {
  console.log("Відправляю звіт на сервер:", config.serverUrl);

  try {
    const res = await fetch(config.serverUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(report)
    });

    console.log("Статус відповіді сервера:", res.status);
    const data = await res.json().catch(() => ({}));
    console.log("Тіло відповіді:", data);
  } catch (err) {
    console.error("Помилка при відправці звіту:", err.message);
  }
}

async function runDemoSession() {
  const config = loadConfig();
  console.log("Конфігурація IoT-клієнта:", config);

  const studentId = process.argv[2] || "student-1";
  console.log("Починаємо сесію для учня:", studentId);

  const session = new DrivingSession(config, studentId);

  const N = 20; 
  for (let i = 0; i < N; i++) {
    const sample = generateSample(config);
    session.addSample(sample);
    console.log(
      `Sample #${i + 1}: speed=${sample.speed}, hardBrake=${sample.hardBrake}, laneViolation=${sample.laneViolation}, overspeed=${sample.overspeedEvent}`
    );
  }

  const report = session.finish();
  console.log("Підсумковий звіт сесії:", report);

  await sendReport(report, config);
}

runDemoSession().catch(err => {
  console.error("Фатальна помилка IoT-клієнта:", err);
});

Config.js
const fs = require("fs");
const path = require("path");

const CONFIG_PATH = path.join(__dirname, "config.json");

function getDefaultConfig() {
  return {
    serverUrl: "http://localhost:3000/api/iot/sessions",
    instructorId: "inst-default",
    groupId: "group-default",
    carId: "car-default",
    sendIntervalSec: 5,
    speedLimit: 60,
    k1: 5,
    k2: 7,
    k3: 3
  };
}

function validateConfig(cfg) {
  if (!cfg.serverUrl || typeof cfg.serverUrl !== "string") return false;
  if (!cfg.instructorId || !cfg.groupId || !cfg.carId) return false;
  if (typeof cfg.sendIntervalSec !== "number" || cfg.sendIntervalSec <= 0) return false;
  if (typeof cfg.speedLimit !== "number" || cfg.speedLimit <= 0) return false;
  if (cfg.k1 <= 0 || cfg.k2 <= 0 || cfg.k3 <= 0) return false;
  return true;
}

function loadConfig() {
  try {
    const raw = fs.readFileSync(CONFIG_PATH, "utf-8");
    const cfg = JSON.parse(raw);
    if (!validateConfig(cfg)) {
      console.warn("Конфігурація некоректна, використовую значення за замовчуванням.");
      return getDefaultConfig();
    }
    return cfg;
  } catch (e) {
    console.warn("Не вдалося прочитати config.json, використовую значення за замовчуванням.");
    return getDefaultConfig();
  }
}

module.exports = {
  loadConfig,
  getDefaultConfig
};

Config.json
{
  "serverUrl": "http://localhost:3000/api/iot/sessions",
  "instructorId": "inst-1",
  "groupId": "group-1",
  "carId": "car-1",
  "sendIntervalSec": 3,
  "speedLimit": 60,
  "k1": 5,
  "k2": 7,
  "k3": 3
}

Sensor.js

function generateSample(config) {
  // швидкість 
  const speed = Math.round(Math.random() * 100);

  // випадкові події 
  const hardBrake = Math.random() < 0.1 ? 1 : 0;      
  const laneViolation = Math.random() < 0.07 ? 1 : 0; 

  const overspeedEvent = speed > config.speedLimit ? 1 : 0;

  return {
    speed,
    hardBrake,
    laneViolation,
    overspeedEvent
  };
}

module.exports = { generateSample };

session.js
class DrivingSession {
  constructor(config, studentId) {
    this.config = config;
    this.studentId = studentId;

    this.speeds = [];
    this.hardBrakesTotal = 0;
    this.laneViolationsTotal = 0;
    this.overspeedEventsTotal = 0;

    this.startedAt = new Date();
    this.finishedAt = null;
  }

  addSample(sample) {
    this.speeds.push(sample.speed);
    this.hardBrakesTotal += sample.hardBrake;
    this.laneViolationsTotal += sample.laneViolation;
    this.overspeedEventsTotal += sample.overspeedEvent;
  }

  computeScore() {
    const { k1, k2, k3 } = this.config;
    const penalty =
      k1 * this.hardBrakesTotal +
      k2 * this.laneViolationsTotal +
      k3 * this.overspeedEventsTotal;
    const rawScore = 100 - penalty;
    return Math.max(0, rawScore);
  }

  getCategory(score) {
    if (score >= 80) return "Good";
    if (score >= 50) return "Need improvement";
    return "Bad";
  }

  finish() {
    this.finishedAt = new Date();

    const n = this.speeds.length || 1;
    const sumSpeed = this.speeds.reduce((acc, v) => acc + v, 0);
    const avgSpeed = sumSpeed / n;

    const score = this.computeScore();
    const category = this.getCategory(score);

    const durationMs = this.finishedAt - this.startedAt;
    const durationSec = Math.round(durationMs / 1000);

    return {
      studentId: this.studentId,
      instructorId: this.config.instructorId,
      groupId: this.config.groupId,
      carId: this.config.carId,
      startedAt: this.startedAt.toISOString(),
      finishedAt: this.finishedAt.toISOString(),
      durationSec,
      avgSpeed,
      hardBrakesTotal: this.hardBrakesTotal,
      laneViolationsTotal: this.laneViolationsTotal,
      overspeedEventsTotal: this.overspeedEventsTotal,
      score,
      category
    };
  }
}

module.exports = DrivingSession;




ДОДАТОК Б
Посилання на код
https://github.com/NureTavdhiridzeDavyd/ark-pzpi-23-7-tavdhiridze-davyd


ДОДАТОК B
Посилання на відеозапис
https://youtu.be/sdvoYiac0zk


